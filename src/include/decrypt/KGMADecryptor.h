#pragma once

#include <string>
#include <fstream>
#include <vector>
#include <filesystem>
#include <cstring>
#include <iostream> // 用于简单的错误打印，可视情况移除

class KGMA
{
private:
    // 类型定义
    enum MType { VPR, KGM, OTHER };

    // ----------------------------------------------------------------------
    // [数据表区域] 请确保保留原有的表数据，这里必须是 static constexpr
    // ----------------------------------------------------------------------
    constexpr static unsigned char VprHeader[] = { 0x05, 0x28, 0xBC, 0x96, 0xE9, 0xE4, 0x5A, 0x43,0x91, 0xAA, 0xBD, 0xD0, 0x7A, 0xF5, 0x36, 0x31 };
    constexpr static unsigned char KgmHeader[] = { 0x7C, 0xD5, 0x32, 0xEB, 0x86, 0x02, 0x7F, 0x4B,0xA8, 0xAF, 0xA6, 0x8E, 0x0F, 0xFF, 0x99, 0x14 };
    constexpr static unsigned char VprMaskDiff[] = { 0x25, 0xDF, 0xE8, 0xA6, 0x75, 0x1E, 0x75, 0x0E,0x2F, 0x80, 0xF3, 0x2D, 0xB8, 0xB6, 0xE3, 0x11, 0x00 };

    constexpr static char FLAC_HEAD[4] = { 'f', 'L', 'a', 'C' };
    constexpr static char MP3_HEAD[3] = { 'I', 'D', '3' };

    constexpr static unsigned char table1[] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x01, 0x21, 0x01, 0x61, 0x01, 0x21, 0x01, 0xe1, 0x01, 0x21, 0x01, 0x61, 0x01, 0x21, 0x01,
		0xd2, 0x23, 0x02, 0x02, 0x42, 0x42, 0x02, 0x02, 0xc2, 0xc2, 0x02, 0x02, 0x42, 0x42, 0x02, 0x02,
		0xd3, 0xd3, 0x02, 0x03, 0x63, 0x43, 0x63, 0x03, 0xe3, 0xc3, 0xe3, 0x03, 0x63, 0x43, 0x63, 0x03,
		0x94, 0xb4, 0x94, 0x65, 0x04, 0x04, 0x04, 0x04, 0x84, 0x84, 0x84, 0x84, 0x04, 0x04, 0x04, 0x04,
		0x95, 0x95, 0x95, 0x95, 0x04, 0x05, 0x25, 0x05, 0xe5, 0x85, 0xa5, 0x85, 0xe5, 0x05, 0x25, 0x05,
		0xd6, 0xb6, 0x96, 0xb6, 0xd6, 0x27, 0x06, 0x06, 0xc6, 0xc6, 0x86, 0x86, 0xc6, 0xc6, 0x06, 0x06,
		0xd7, 0xd7, 0x97, 0x97, 0xd7, 0xd7, 0x06, 0x07, 0xe7, 0xc7, 0xe7, 0x87, 0xe7, 0xc7, 0xe7, 0x07,
		0x18, 0x38, 0x18, 0x78, 0x18, 0x38, 0x18, 0xe9, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x08, 0x09, 0x29, 0x09, 0x69, 0x09, 0x29, 0x09,
		0xda, 0x3a, 0x1a, 0x3a, 0x5a, 0x3a, 0x1a, 0x3a, 0xda, 0x2b, 0x0a, 0x0a, 0x4a, 0x4a, 0x0a, 0x0a,
		0xdb, 0xdb, 0x1b, 0x1b, 0x5b, 0x5b, 0x1b, 0x1b, 0xdb, 0xdb, 0x0a, 0x0b, 0x6b, 0x4b, 0x6b, 0x0b,
		0x9c, 0xbc, 0x9c, 0x7c, 0x1c, 0x3c, 0x1c, 0x7c, 0x9c, 0xbc, 0x9c, 0x6d, 0x0c, 0x0c, 0x0c, 0x0c,
		0x9d, 0x9d, 0x9d, 0x9d, 0x1d, 0x1d, 0x1d, 0x1d, 0x9d, 0x9d, 0x9d, 0x9d, 0x0c, 0x0d, 0x2d, 0x0d,
		0xde, 0xbe, 0x9e, 0xbe, 0xde, 0x3e, 0x1e, 0x3e, 0xde, 0xbe, 0x9e, 0xbe, 0xde, 0x2f, 0x0e, 0x0e,
		0xdf, 0xdf, 0x9f, 0x9f, 0xdf, 0xdf, 0x1f, 0x1f, 0xdf, 0xdf, 0x9f, 0x9f, 0xdf, 0xdf, 0x0e, 0x0f,
		0x00, 0x20, 0x00, 0x60, 0x00, 0x20, 0x00, 0xe0, 0x00, 0x20, 0x00, 0x60, 0x00, 0x20, 0x00, 0xf1
	};

	constexpr static unsigned char table2[] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x01, 0x23, 0x01, 0x67, 0x01, 0x23, 0x01, 0xef, 0x01, 0x23, 0x01, 0x67, 0x01, 0x23, 0x01,
		0xdf, 0x21, 0x02, 0x02, 0x46, 0x46, 0x02, 0x02, 0xce, 0xce, 0x02, 0x02, 0x46, 0x46, 0x02, 0x02,
		0xde, 0xde, 0x02, 0x03, 0x65, 0x47, 0x65, 0x03, 0xed, 0xcf, 0xed, 0x03, 0x65, 0x47, 0x65, 0x03,
		0x9d, 0xbf, 0x9d, 0x63, 0x04, 0x04, 0x04, 0x04, 0x8c, 0x8c, 0x8c, 0x8c, 0x04, 0x04, 0x04, 0x04,
		0x9c, 0x9c, 0x9c, 0x9c, 0x04, 0x05, 0x27, 0x05, 0xeb, 0x8d, 0xaf, 0x8d, 0xeb, 0x05, 0x27, 0x05,
		0xdb, 0xbd, 0x9f, 0xbd, 0xdb, 0x25, 0x06, 0x06, 0xca, 0xca, 0x8e, 0x8e, 0xca, 0xca, 0x06, 0x06,
		0xda, 0xda, 0x9e, 0x9e, 0xda, 0xda, 0x06, 0x07, 0xe9, 0xcb, 0xe9, 0x8f, 0xe9, 0xcb, 0xe9, 0x07,
		0x19, 0x3b, 0x19, 0x7f, 0x19, 0x3b, 0x19, 0xe7, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x08, 0x09, 0x2b, 0x09, 0x6f, 0x09, 0x2b, 0x09,
		0xd7, 0x39, 0x1b, 0x39, 0x5f, 0x39, 0x1b, 0x39, 0xd7, 0x29, 0x0a, 0x0a, 0x4e, 0x4e, 0x0a, 0x0a,
		0xd6, 0xd6, 0x1a, 0x1a, 0x5e, 0x5e, 0x1a, 0x1a, 0xd6, 0xd6, 0x0a, 0x0b, 0x6d, 0x4f, 0x6d, 0x0b,
		0x95, 0xb7, 0x95, 0x7b, 0x1d, 0x3f, 0x1d, 0x7b, 0x95, 0xb7, 0x95, 0x6b, 0x0c, 0x0c, 0x0c, 0x0c,
		0x94, 0x94, 0x94, 0x94, 0x1c, 0x1c, 0x1c, 0x1c, 0x94, 0x94, 0x94, 0x94, 0x0c, 0x0d, 0x2f, 0x0d,
		0xd3, 0xb5, 0x97, 0xb5, 0xd3, 0x3d, 0x1f, 0x3d, 0xd3, 0xb5, 0x97, 0xb5, 0xd3, 0x2d, 0x0e, 0x0e,
		0xd2, 0xd2, 0x96, 0x96, 0xd2, 0xd2, 0x1e, 0x1e, 0xd2, 0xd2, 0x96, 0x96, 0xd2, 0xd2, 0x0e, 0x0f,
		0x00, 0x22, 0x00, 0x66, 0x00, 0x22, 0x00, 0xee, 0x00, 0x22, 0x00, 0x66, 0x00, 0x22, 0x00, 0xfe
	};

	constexpr static unsigned char MaskV2PreDef[] = {
		0xB8, 0xD5, 0x3D, 0xB2, 0xE9, 0xAF, 0x78, 0x8C, 0x83, 0x33, 0x71, 0x51, 0x76, 0xA0, 0xCD, 0x37,
		0x2F, 0x3E, 0x35, 0x8D, 0xA9, 0xBE, 0x98, 0xB7, 0xE7, 0x8C, 0x22, 0xCE, 0x5A, 0x61, 0xDF, 0x68,
		0x69, 0x89, 0xFE, 0xA5, 0xB6, 0xDE, 0xA9, 0x77, 0xFC, 0xC8, 0xBD, 0xBD, 0xE5, 0x6D, 0x3E, 0x5A,
		0x36, 0xEF, 0x69, 0x4E, 0xBE, 0xE1, 0xE9, 0x66, 0x1C, 0xF3, 0xD9, 0x02, 0xB6, 0xF2, 0x12, 0x9B,
		0x44, 0xD0, 0x6F, 0xB9, 0x35, 0x89, 0xB6, 0x46, 0x6D, 0x73, 0x82, 0x06, 0x69, 0xC1, 0xED, 0xD7,
		0x85, 0xC2, 0x30, 0xDF, 0xA2, 0x62, 0xBE, 0x79, 0x2D, 0x62, 0x62, 0x3D, 0x0D, 0x7E, 0xBE, 0x48,
		0x89, 0x23, 0x02, 0xA0, 0xE4, 0xD5, 0x75, 0x51, 0x32, 0x02, 0x53, 0xFD, 0x16, 0x3A, 0x21, 0x3B,
		0x16, 0x0F, 0xC3, 0xB2, 0xBB, 0xB3, 0xE2, 0xBA, 0x3A, 0x3D, 0x13, 0xEC, 0xF6, 0x01, 0x45, 0x84,
		0xA5, 0x70, 0x0F, 0x93, 0x49, 0x0C, 0x64, 0xCD, 0x31, 0xD5, 0xCC, 0x4C, 0x07, 0x01, 0x9E, 0x00,
		0x1A, 0x23, 0x90, 0xBF, 0x88, 0x1E, 0x3B, 0xAB, 0xA6, 0x3E, 0xC4, 0x73, 0x47, 0x10, 0x7E, 0x3B,
		0x5E, 0xBC, 0xE3, 0x00, 0x84, 0xFF, 0x09, 0xD4, 0xE0, 0x89, 0x0F, 0x5B, 0x58, 0x70, 0x4F, 0xFB,
		0x65, 0xD8, 0x5C, 0x53, 0x1B, 0xD3, 0xC8, 0xC6, 0xBF, 0xEF, 0x98, 0xB0, 0x50, 0x4F, 0x0F, 0xEA,
		0xE5, 0x83, 0x58, 0x8C, 0x28, 0x2C, 0x84, 0x67, 0xCD, 0xD0, 0x9E, 0x47, 0xDB, 0x27, 0x50, 0xCA,
		0xF4, 0x63, 0x63, 0xE8, 0x97, 0x7F, 0x1B, 0x4B, 0x0C, 0xC2, 0xC1, 0x21, 0x4C, 0xCC, 0x58, 0xF5,
		0x94, 0x52, 0xA3, 0xF3, 0xD3, 0xE0, 0x68, 0xF4, 0x00, 0x23, 0xF3, 0x5E, 0x0A, 0x7B, 0x93, 0xDD,
		0xAB, 0x12, 0xB2, 0x13, 0xE8, 0x84, 0xD7, 0xA7, 0x9F, 0x0F, 0x32, 0x4C, 0x55, 0x1D, 0x04, 0x36,
		0x52, 0xDC, 0x03, 0xF3, 0xF9, 0x4E, 0x42, 0xE9, 0x3D, 0x61, 0xEF, 0x7C, 0xB6, 0xB3, 0x93, 0x50,
	};

    // ----------------------------------------------------------------------
    // [静态辅助函数]
    // ----------------------------------------------------------------------

    // 检查头并返回类型引用
    static bool CheckHeader(std::ifstream& fs, MType& detectedType)
    {
        char magic[16];
        fs.read(magic, 16);
        if (fs.gcount() < 16) return false;

        if (std::memcmp(magic, VprHeader, 16) == 0) { detectedType = VPR; return true; }
        if (std::memcmp(magic, KgmHeader, 16) == 0) { detectedType = KGM; return true; }

        return false;
    }

    static std::string GetKey(std::ifstream& fs)
    {
        char key[17] = {0};
        fs.seekg(28, std::ios::beg);
        fs.read(key, 16);
        return std::string(key, 16);
    }

    // 处理缓冲区 (注意：现在需要传入 type，因为无法访问非静态成员)
    static void ProcessBuffer(char* buffer, size_t size, size_t& pos, const std::string& key, MType type)
    {
        unsigned char med8, msk8;
        size_t offset;
        const size_t keyLen = 17;

        for (size_t i = 0; i < size; i++)
        {
            med8 = key[pos % keyLen] ^ buffer[i];
            med8 ^= (med8 & 15) << 4;

            msk8 = 0;
            offset = pos >> 4;
            while (offset >= 0x11)
            {
                // 注意：这里需要你上面定义的 table1 和 table2
                msk8 ^= table1[offset % 272];
                offset >>= 4;
                msk8 ^= table2[offset % 272];
                offset >>= 4;
            }
            msk8 = MaskV2PreDef[pos % 272] ^ msk8;
            msk8 ^= (msk8 & 15) << 4;

            buffer[i] = med8 ^ msk8;
            if (type == VPR) { buffer[i] ^= VprMaskDiff[pos % 17]; }
            pos++;
        }
    }

public:
    /**
     * @brief 静态调用解密函数
     * @return 成功返回解密后文件的绝对路径字符串，失败返回 ""
     */
    static std::string KGMADecrypt(const std::filesystem::path& originalFilePath, std::filesystem::path _outputPath = "")
    {
        namespace fs = std::filesystem;

        // 使用 try-catch 捕获所有潜在错误，保证失败时返回 ""
        try {
            std::ifstream inFile(originalFilePath, std::ios::binary);
            if (!inFile) return "";

            // 局部变量存储类型
            MType currentType = OTHER;

            // 1. 检查文件头
            if (!CheckHeader(inFile, currentType)) {
                // 不是加密文件，返回空字符串表示“未执行解密”或“失败”
                return "";
            }

            // 2. 获取Key
            inFile.seekg(16, std::ios::beg);
            int headerLen = 0;
            inFile.read(reinterpret_cast<char*>(&headerLen), 4);
            std::string key = GetKey(inFile);

            // 3. 准备输出目录
            if (_outputPath.empty()) {
                _outputPath = originalFilePath.parent_path();
            }
            if (!fs::exists(_outputPath)) {
                fs::create_directories(_outputPath);
            }

            // 4. 准备缓冲区
            const size_t BUFFER_SIZE = 1024 * 64; // 64KB
            std::vector<char> buffer(BUFFER_SIZE);
            size_t pos = 0;

            // 定位数据区
            inFile.seekg(headerLen, std::ios::beg);

            std::ofstream outFile;
            std::string resultPathString = ""; // 用于存储最终返回的路径
            bool firstBlock = true;

            // 5. 循环处理
            while (inFile) {
                inFile.read(buffer.data(), BUFFER_SIZE);
                std::streamsize bytesRead = inFile.gcount();
                if (bytesRead <= 0) break;

                // 传入 currentType 进行解密
                ProcessBuffer(buffer.data(), static_cast<size_t>(bytesRead), pos, key, currentType);

                // 在第一块解密后确定后缀名并创建文件
            	if (firstBlock) {
            		std::string ext = ".mp3"; // 默认
            		if (bytesRead >= 4 && std::memcmp(buffer.data(), FLAC_HEAD, 4) == 0) {
            			ext = ".flac";
            		} else if (bytesRead >= 3 && std::memcmp(buffer.data(), MP3_HEAD, 3) == 0) {
            			ext = ".mp3";
            		}

            		// --- 修改开始 ---

            		// 1. 获取不带后缀的文件名 (例如: "G.E.M. 邓紫棋 - 天空没有极限")
            		fs::path stemName = originalFilePath.stem();

            		// 2. 直接拼接后缀，而不是替换后缀
            		// std::filesystem::path 重载了 += 运算符，这样是安全的，不会误判点号
            		stemName += ext;

            		// 3. 组合完整路径
            		fs::path fullOutputPath = _outputPath / stemName;

            		// --- 修改结束 ---

            		outFile.open(fullOutputPath, std::ios::binary);
            		if (!outFile) return ""; // 创建失败

            		resultPathString = fullOutputPath.string();

            		firstBlock = false;
            	}

                outFile.write(buffer.data(), bytesRead);
            }

            outFile.close();
            inFile.close();

            return resultPathString; // 返回成功路径

        } catch (...) {
            return ""; // 发生任何异常返回空
        }
    }
};